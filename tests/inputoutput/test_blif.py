import unittest
import pyrtl
import six
from pyrtl.rtllib import testingutils as utils

full_adder_blif = """\
# Generated by Yosys 0.3.0+ (git sha1 7e758d5, clang 3.4-1ubuntu3 -fPIC -Os)
.model full_adder
.inputs x y cin
.outputs sum cout
.names $false
.names $true
1
.names y $not$FA.v:12$3_Y
0 1
.names x $not$FA.v:11$1_Y
0 1
.names cin $not$FA.v:15$6_Y
0 1
.names ind3 ind4 sum
1- 1
-1 1
.names $not$FA.v:15$6_Y ind2 ind3
11 1
.names x $not$FA.v:12$3_Y ind1
11 1
.names ind2 $not$FA.v:16$8_Y
0 1
.names cin $not$FA.v:16$8_Y ind4
11 1
.names x y $and$FA.v:19$11_Y
11 1
.names ind0 ind1 ind2
1- 1
-1 1
.names cin ind2 $and$FA.v:19$12_Y
11 1
.names $and$FA.v:19$11_Y $and$FA.v:19$12_Y cout
1- 1
-1 1
.names $not$FA.v:11$1_Y y ind0
11 1
.end
"""

state_machine_blif = """\
# Generated by Yosys 0.5+     420 (git sha1 1d62f87, clang 7.0.2 -fPIC -Os)

.model statem
.inputs clk in reset
.outputs out[0] out[1] out[2] out[3]
.names $false
.names $true
1
.names $undef
.names in state[2] $abc$129$n11_1
11 1
.names $abc$129$n11_1 state[3] $auto$fsm_map.cc:238:map_fsm$30[0]
1- 1
-1 1
.names state[2] $abc$129$n13
0 1
.names state[0] $abc$129$n14_1
0 1
.names state[2] state[1] $abc$129$n15
00 1
.names $abc$129$n15 $abc$129$n14_1 $abc$129$n13 out[0]
-00 1
0-0 1
.names state[1] $abc$129$n17
0 1
.names $abc$129$n15 $abc$129$n14_1 $abc$129$n17 out[1]
-00 1
0-0 1
.names $abc$129$n15 $abc$129$n14_1 out[2]
11 1
.names in $abc$129$n13 $auto$fsm_map.cc:118:implement_pattern_cache$38
00 1
# .subckt $_DFF_PP1_ C=clk D=$auto$fsm_map.cc:238:map_fsm$30[0] Q=state[0] R=reset
# .subckt $_DFF_PP0_ C=clk D=$auto$fsm_map.cc:118:implement_pattern_cache$38 Q=state[1] R=reset
# .subckt $_DFF_PP0_ C=clk D=state[0] Q=state[2] R=reset
# .subckt $_DFF_PP0_ C=clk D=state[1] Q=state[3] R=reset
.names $false out[3]
1 1
.end
"""

# Manually set the .latch's init values from 2 to arbitrary non-1 numbers, for testing.
# Should result in the same logic, but allows for testing the parser.
counter4bit_blif = """\
# Generated by Yosys 0.9 (git sha1 UNKNOWN, clang 11.0.0 -fPIC -Os)

.model counter
.inputs clk rst en
.outputs count[0] count[1] count[2] count[3]
.names $false
.names $true
1
.names $undef
.names count[0] $add$counter.v:10$2_Y[0] en $procmux$3_Y[0]
1-0 1
-11 1
.names count[1] $add$counter.v:10$2_Y[1] en $procmux$3_Y[1]
1-0 1
-11 1
.names count[2] $add$counter.v:10$2_Y[2] en $procmux$3_Y[2]
1-0 1
-11 1
.names count[3] $add$counter.v:10$2_Y[3] en $procmux$3_Y[3]
1-0 1
-11 1
.names $procmux$3_Y[0] $false rst $0\count[3:0][0]
1-0 1
-11 1
.names $procmux$3_Y[1] $false rst $0\count[3:0][1]
1-0 1
-11 1
.names $procmux$3_Y[2] $false rst $0\count[3:0][2]
1-0 1
-11 1
.names $procmux$3_Y[3] $false rst $0\count[3:0][3]
1-0 1
-11 1
.latch $0\count[3:0][0] count[0] re clk 2
.latch $0\count[3:0][1] count[1] re clk 0
.latch $0\count[3:0][2] count[2] re clk 3
.latch $0\count[3:0][3] count[3] re clk
.names count[1] count[0] $techmap$add$counter.v:10$2.$auto$alumacc.cc:474:replace_alu$53.lcu.g[1]
11 1
.names count[2] $techmap$add$counter.v:10$2.$auto$alumacc.cc:474:replace_alu$53.lcu.g[1] $techmap$add$counter.v:10$2.$auto$alumacc.cc:474:replace_alu$53.lcu.g[2]
11 1
.names count[1] count[0] $add$counter.v:10$2_Y[1]
10 1
01 1
.names count[2] $techmap$add$counter.v:10$2.$auto$alumacc.cc:474:replace_alu$53.lcu.g[1] $add$counter.v:10$2_Y[2]
10 1
01 1
.names count[3] $techmap$add$counter.v:10$2.$auto$alumacc.cc:474:replace_alu$53.lcu.g[2] $add$counter.v:10$2_Y[3]
10 1
01 1
.names count[0] $true $add$counter.v:10$2_Y[0]
10 1
01 1
.names count[0] $techmap$add$counter.v:10$2.$auto$alumacc.cc:474:replace_alu$53.lcu.g[0]
1 1
.end
"""  # noqa

counter4bit_blif_bad_latch_inits = """\
# Generated by Yosys 0.9 (git sha1 UNKNOWN, clang 11.0.0 -fPIC -Os)

.model counter
.inputs clk rst en
.outputs count[0] count[1] count[2] count[3]
.names $false
.names $true
1
.names $undef
.names count[0] $add$counter.v:10$2_Y[0] en $procmux$3_Y[0]
1-0 1
-11 1
.names count[1] $add$counter.v:10$2_Y[1] en $procmux$3_Y[1]
1-0 1
-11 1
.names count[2] $add$counter.v:10$2_Y[2] en $procmux$3_Y[2]
1-0 1
-11 1
.names count[3] $add$counter.v:10$2_Y[3] en $procmux$3_Y[3]
1-0 1
-11 1
.names $procmux$3_Y[0] $false rst $0\count[3:0][0]
1-0 1
-11 1
.names $procmux$3_Y[1] $false rst $0\count[3:0][1]
1-0 1
-11 1
.names $procmux$3_Y[2] $false rst $0\count[3:0][2]
1-0 1
-11 1
.names $procmux$3_Y[3] $false rst $0\count[3:0][3]
1-0 1
-11 1
.latch $0\count[3:0][0] count[0] re clk 1
.latch $0\count[3:0][1] count[1] re clk 1
.latch $0\count[3:0][2] count[2] re clk 0
.latch $0\count[3:0][3] count[3] re clk 2
.names count[1] count[0] $techmap$add$counter.v:10$2.$auto$alumacc.cc:474:replace_alu$53.lcu.g[1]
11 1
.names count[2] $techmap$add$counter.v:10$2.$auto$alumacc.cc:474:replace_alu$53.lcu.g[1] $techmap$add$counter.v:10$2.$auto$alumacc.cc:474:replace_alu$53.lcu.g[2]
11 1
.names count[1] count[0] $add$counter.v:10$2_Y[1]
10 1
01 1
.names count[2] $techmap$add$counter.v:10$2.$auto$alumacc.cc:474:replace_alu$53.lcu.g[1] $add$counter.v:10$2_Y[2]
10 1
01 1
.names count[3] $techmap$add$counter.v:10$2.$auto$alumacc.cc:474:replace_alu$53.lcu.g[2] $add$counter.v:10$2_Y[3]
10 1
01 1
.names count[0] $true $add$counter.v:10$2_Y[0]
10 1
01 1
.names count[0] $techmap$add$counter.v:10$2.$auto$alumacc.cc:474:replace_alu$53.lcu.g[0]
1 1
.end
"""  # noqa

blif_with_output_as_arg = """
# Generated by Yosys 0.9+2406 (git sha1 aee43936, clang 11.0.3 -fPIC -Os)

.model Top
.inputs clk in[0] in[1]
.outputs out
.names $false
.names $true
1
.names $undef
.names out $techmap$add$test.v:9$6.$auto$alumacc.cc:485:replace_alu$60.X[0]
0 1
.names in[0] $not$test.v:6$1_Y[0]
0 1
.names r[0] $not$test.v:6$3_Y[0]
0 1
.latch $techmap$add$test.v:9$6.$auto$alumacc.cc:485:replace_alu$60.X[0] r[0] re clk 2
.names $not$test.v:6$1_Y[0] $not$test.v:6$3_Y[0] out
10 1
01 1
.names $true $not$test.v:6$3_Y[1]
1 1
.names $false $techmap$add$test.v:9$6.$auto$alumacc.cc:485:replace_alu$60.X[1]
1 1
.names $false $techmap$add$test.v:9$6.$auto$alumacc.cc:485:replace_alu$60.X[2]
1 1
.end
"""  # noqa

simple_unmerged_io_blif = """
# Generated by Yosys 0.9+2406 (git sha1 aee43936, clang 11.0.3 -fPIC -Os)

.model top
.inputs a[0] a[1] a[2] a[3]
.outputs b[0] b[1]
.names $false
.names $true
1
.names $undef
.names a[0] b[0]
1 1
.names a[2] b[1]
1 1
.end
"""  # noqa

four_bit_adder_multi_module = """
# Generated by Yosys 0.9+2406 (git sha1 aee43936, clang 11.0.3 -fPIC -Os)

.model four_bit_adder
.inputs a[0] a[1] a[2] a[3] b[0] b[1] b[2] b[3] cin
.outputs s[0] s[1] s[2] s[3] cout
.names $false
.names $true
1
.names $undef
.subckt full_adder a=a[0] b=b[0] cin=cin cout=cout0 s=s[0]
.subckt full_adder a=a[1] b=b[1] cin=cout0 cout=cout1 s=s[1]
.subckt full_adder a=a[2] b=b[2] cin=cout1 cout=cout2 s=s[2]
.subckt full_adder a=a[3] b=b[3] cin=cout2 cout=cout s=s[3]
.end

.model full_adder
.inputs a b cin
.outputs s cout
.names $false
.names $true
1
.names $undef
.names a b $techmap$add$four_bit_adder_subsub.v:34$1.$auto$alumacc.cc:485:replace_alu$46.X[0]
10 1
01 1
.names a b $techmap$add$four_bit_adder_subsub.v:34$1.$auto$alumacc.cc:485:replace_alu$46.CO[0]
11 1
.names $techmap$add$four_bit_adder_subsub.v:34$1.$auto$alumacc.cc:485:replace_alu$46.CO[0] $techmap$add$four_bit_adder_subsub.v:34$2.$auto$alumacc.cc:485:replace_alu$49.CO[0] x
10 1
01 1
.names cin $techmap$add$four_bit_adder_subsub.v:34$1.$auto$alumacc.cc:485:replace_alu$46.X[0] s
10 1
01 1
.names cin $techmap$add$four_bit_adder_subsub.v:34$1.$auto$alumacc.cc:485:replace_alu$46.X[0] $techmap$add$four_bit_adder_subsub.v:34$2.$auto$alumacc.cc:485:replace_alu$49.CO[0]
11 1
.subckt pass_through x=x y=y
.subckt pass_through x=y y=cout
.names $false $techmap$add$four_bit_adder_subsub.v:34$1.$auto$alumacc.cc:485:replace_alu$46.CO[1]
1 1
.names $false $techmap$add$four_bit_adder_subsub.v:34$1.$auto$alumacc.cc:485:replace_alu$46.X[1]
1 1
.end

.model pass_through
.inputs x
.outputs y
.names $false
.names $true
1
.names $undef
.names x y
1 1
.end
"""  # noqa

clock_passing_blif = """
# Generated by Yosys 0.9+2406 (git sha1 aee43936, clang 11.0.3 -fPIC -Os)

.model top
.inputs clk a[0] a[1] a[2] a[3] b[0] b[1] b[2] b[3]
.outputs c[0] c[1] c[2] c[3]
.names $false
.names $true
1
.names $undef
.names b[0] w2[0] c[0]
11 1
.names b[1] w2[1] c[1]
11 1
.names b[2] w2[2] c[2]
11 1
.names b[3] w2[3] c[3]
11 1
.subckt passthrough a[0]=a[0] a[1]=a[1] a[2]=a[2] a[3]=a[3] c[0]=w1[0] c[1]=w1[1] c[2]=w1[2] c[3]=w1[3] pclk=clk
.subckt passthrough a[0]=w1[0] a[1]=w1[1] a[2]=w1[2] a[3]=w1[3] c[0]=w2[0] c[1]=w2[1] c[2]=w2[2] c[3]=w2[3] pclk=clk
.end

.model my_4bit_dff
.inputs mclk din[0] din[1] din[2] din[3] en
.outputs q[0] q[1] q[2] q[3]
.names $false
.names $true
1
.names $undef
.names q[0] din[0] en $0\q[3:0][0]
1-0 1
-11 1
.names q[1] din[1] en $0\q[3:0][1]
1-0 1
-11 1
.names q[2] din[2] en $0\q[3:0][2]
1-0 1
-11 1
.names q[3] din[3] en $0\q[3:0][3]
1-0 1
-11 1
.latch $0\q[3:0][0] q[0] re mclk 2
.latch $0\q[3:0][1] q[1] re mclk 2
.latch $0\q[3:0][2] q[2] re mclk 2
.latch $0\q[3:0][3] q[3] re mclk 2
.end

.model passthrough
.inputs a[0] a[1] a[2] a[3] pclk
.outputs c[0] c[1] c[2] c[3]
.names $false
.names $true
1
.names $undef
.subckt my_4bit_dff din[0]=a[0] din[1]=a[1] din[2]=a[2] din[3]=a[3] en=$true mclk=pclk q[0]=c[0] q[1]=c[1] q[2]=c[2] q[3]=c[3]
.end
"""  # noqa


class TestInputFromBlif(unittest.TestCase):
    def setUp(self):
        pyrtl.reset_working_block()

    def test_combo_blif_input_has_correct_io_interface(self):
        pyrtl.input_from_blif(full_adder_blif)
        x, y, cin, sumw, cout, bad = [
            pyrtl.working_block().get_wirevector_by_name(s)
            for s in ['x', 'y', 'cin', 'sum', 'cout', 'bad']
        ]
        self.assertIsNotNone(x)
        self.assertIsNotNone(y)
        self.assertIsNotNone(cin)
        self.assertIsNotNone(sumw)
        self.assertIsNotNone(cout)
        self.assertIsNone(bad)
        self.assertEquals(len(x), 1)
        self.assertEquals(len(y), 1)
        self.assertEquals(len(cin), 1)
        self.assertEquals(len(sumw), 1)
        self.assertEquals(len(cout), 1)
        io_input = pyrtl.working_block().wirevector_subset(pyrtl.Input)
        self.assertIn(x, io_input)
        self.assertIn(y, io_input)
        self.assertIn(cin, io_input)
        io_output = pyrtl.working_block().wirevector_subset(pyrtl.Output)
        self.assertIn(sumw, io_output)
        self.assertIn(cout, io_output)

    def test_sequential_blif_input_has_correct_io_interface(self):
        pyrtl.input_from_blif(state_machine_blif)
        inw, reset, out = [
            pyrtl.working_block().get_wirevector_by_name(s)
            for s in ['in', 'reset', 'out']
        ]
        self.assertIsNotNone(inw)
        self.assertIsNotNone(reset)
        self.assertIsNotNone(out)
        self.assertEquals(len(inw), 1)
        self.assertEquals(len(reset), 1)
        self.assertEquals(len(out), 4)
        io_input = pyrtl.working_block().wirevector_subset(pyrtl.Input)
        self.assertIn(inw, io_input)
        self.assertIn(reset, io_input)
        io_output = pyrtl.working_block().wirevector_subset(pyrtl.Output)
        self.assertIn(out, io_output)

    def test_sequential_blif_input_has_correct_io_interface_counter(self):
        pyrtl.input_from_blif(counter4bit_blif)
        rst, en, count = [
            pyrtl.working_block().get_wirevector_by_name(s)
            for s in ['rst', 'en', 'count']
        ]
        self.assertIsNotNone(rst)
        self.assertIsNotNone(en)
        self.assertIsNotNone(count)
        self.assertEquals(len(rst), 1)
        self.assertEquals(len(en), 1)
        self.assertEquals(len(count), 4)
        io_input = pyrtl.working_block().wirevector_subset(pyrtl.Input)
        self.assertIn(rst, io_input)
        self.assertIn(en, io_input)
        io_output = pyrtl.working_block().wirevector_subset(pyrtl.Output)
        self.assertIn(count, io_output)

    def test_correct_interface_with_unmerged_io(self):
        pyrtl.input_from_blif(simple_unmerged_io_blif, merge_io_vectors=False)
        a0, a1, a2, a3, b0, b1 = [
            pyrtl.working_block().get_wirevector_by_name(s)
            for s in ['a[0]', 'a[1]', 'a[2]', 'a[3]', 'b[0]', 'b[1]']
        ]
        self.assertEquals(len(a0), 1)
        self.assertEquals(len(a1), 1)
        self.assertEquals(len(a2), 1)
        self.assertEquals(len(a3), 1)
        self.assertEquals(len(b0), 1)
        self.assertEquals(len(b1), 1)
        self.assertEquals({a0, a1, a2, a3}, pyrtl.working_block().wirevector_subset(pyrtl.Input))
        self.assertEquals({b0, b1}, pyrtl.working_block().wirevector_subset(pyrtl.Output))

    def test_blif_input_simulates_correctly_with_merged_outputs(self):
        # The 'counter_blif' string contains a model of a standard 4-bit synchronous-reset
        # counter with enable. In particular, the model has 4 1-bit outputs named "count[0]",
        # "count[1]", "count[2]", and "count[3]". The internal PyRTL representation will by
        # default convert these related 1-bit wires into a single 4-bit wire called "count".
        # This test simulates the design and, among other things, ensures that this output
        # wire conversion occurred correctly.
        pyrtl.input_from_blif(counter4bit_blif)
        io_vectors = pyrtl.working_block().wirevector_subset((pyrtl.Input, pyrtl.Output))
        sim_trace = pyrtl.SimulationTrace(wires_to_track=io_vectors)
        sim = pyrtl.Simulation(sim_trace)
        inputs = {
            'rst': [1] + [0] * 20,
            'en': [1] + [1] * 20,
        }
        expected = {
            'count': [0] + list(range(0, 16)) + list(range(0, 4))
        }
        sim.step_multiple(inputs, expected)

        correct_output = ("  --- Values in base 10 ---\n"
                          "count  0  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15  0  1  2  3\n"
                          "en     1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1\n"
                          "rst    1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n")
        output = six.StringIO()
        sim_trace.print_trace(output)
        self.assertEqual(output.getvalue(), correct_output)

    def test_blif_input_simulates_correctly_with_unmerged_outputs(self):
        pyrtl.input_from_blif(counter4bit_blif, merge_io_vectors=False)
        count0, count1, count2, count3 = [
            pyrtl.working_block().get_wirevector_by_name(s)
            for s in ['count[0]', 'count[1]', 'count[2]', 'count[3]']
        ]
        self.assertEquals(len(count0), 1)
        self.assertEquals(len(count1), 1)
        self.assertEquals(len(count2), 1)
        self.assertEquals(len(count3), 1)
        io_vectors = pyrtl.working_block().wirevector_subset((pyrtl.Input, pyrtl.Output))
        sim_trace = pyrtl.SimulationTrace(wires_to_track=io_vectors)
        sim = pyrtl.Simulation(sim_trace)
        inputs = {
            'rst': [1] + [0] * 20,
            'en': [1] + [1] * 20,
        }
        expected_merged = [0] + list(range(0, 16)) + list(range(0, 4))

        expected = {
            'count[0]': [n & 0b0001 for n in expected_merged],
            'count[1]': [(n & 0b0010) >> 1 for n in expected_merged],
            'count[2]': [(n & 0b0100) >> 2 for n in expected_merged],
            'count[3]': [(n & 0b1000) >> 3 for n in expected_merged],
        }
        sim.step_multiple(inputs, expected)

        correct_output = ("     --- Values in base 10 ---\n"
                          "count[0] 0 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1\n"
                          "count[1] 0 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1\n"
                          "count[2] 0 0 0 0 0 1 1 1 1 0 0 0 0 1 1 1 1 0 0 0 0\n"
                          "count[3] 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 0 0 0 0\n"
                          "en       1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n"
                          "rst      1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n")
        output = six.StringIO()
        sim_trace.print_trace(output)
        self.assertEqual(output.getvalue(), correct_output)

    def test_sequential_blif_input_fails_to_parse_with_bad_latch_init(self):
        with self.assertRaises(pyrtl.PyrtlError):
            pyrtl.input_from_blif(counter4bit_blif_bad_latch_inits)

    def test_blif_with_output_as_arg(self):
        pyrtl.input_from_blif(blif_with_output_as_arg)
        inw, outw = [
            pyrtl.working_block().get_wirevector_by_name(s)
            for s in ['in', 'out']
        ]
        self.assertIsNotNone(inw)
        self.assertIsNotNone(outw)
        self.assertEquals(len(inw), 2)
        self.assertEquals(len(outw), 1)
        io_input = pyrtl.working_block().wirevector_subset(pyrtl.Input)
        self.assertIn(inw, io_input)
        io_output = pyrtl.working_block().wirevector_subset(pyrtl.Output)
        self.assertIn(outw, io_output)

    def test_blif_with_multiple_modules_merged_io(self):
        pyrtl.input_from_blif(four_bit_adder_multi_module)
        a, b, cin, s, cout = [
            pyrtl.working_block().get_wirevector_by_name(s)
            for s in ['a', 'b', 'cin', 's', 'cout']
        ]
        io_input = pyrtl.working_block().wirevector_subset(pyrtl.Input)
        self.assertIn(a, io_input)
        self.assertIn(b, io_input)
        self.assertIn(cin, io_input)
        io_output = pyrtl.working_block().wirevector_subset(pyrtl.Output)
        self.assertIn(s, io_output)
        self.assertIn(cout, io_output)

        self.assertEqual(len(a), 4)
        self.assertEqual(len(b), 4)
        self.assertEqual(len(cin), 1)
        self.assertEqual(len(s), 4)
        self.assertEqual(len(cout), 1)

        avals = list(range(0, 16)) * 2
        bvals = list(range(0, 16)) * 2
        cinvals = [0] * 16 + [1] * 16

        res = utils.sim_and_ret_outws([a, b, cin], [avals, bvals, cinvals])
        self.assertEqual(
            res[s],
            [(av + bv + cinv) & 0xf for av, bv, cinv in zip(avals, bvals, cinvals)]
        )
        self.assertEqual(
            res[cout],
            [((av + bv + cinv) & 0x10) >> 4 for av, bv, cinv in zip(avals, bvals, cinvals)]
        )

    def test_blif_with_multiple_modules_unmerged_io(self):
        pyrtl.input_from_blif(four_bit_adder_multi_module, merge_io_vectors=False)
        a0, a1, a2, a3, b0, b1, b2, b3, cin, s0, s1, s2, s3, cout = [
            pyrtl.working_block().get_wirevector_by_name(s)
            for s in ['a[0]', 'a[1]', 'a[2]', 'a[3]',
                      'b[0]', 'b[1]', 'b[2]', 'b[3]',
                      'cin',
                      's[0]', 's[1]', 's[2]', 's[3]',
                      'cout']
        ]
        io_input = pyrtl.working_block().wirevector_subset(pyrtl.Input)
        self.assertEqual({a0, a1, a2, a3, b0, b1, b2, b3, cin}, io_input)
        io_output = pyrtl.working_block().wirevector_subset(pyrtl.Output)
        self.assertEqual({s0, s1, s2, s3, cout}, io_output)

        self.assertEqual(len(a0), 1)
        self.assertEqual(len(a1), 1)
        self.assertEqual(len(a2), 1)
        self.assertEqual(len(a3), 1)
        self.assertEqual(len(b0), 1)
        self.assertEqual(len(b1), 1)
        self.assertEqual(len(b2), 1)
        self.assertEqual(len(b3), 1)
        self.assertEqual(len(cin), 1)
        self.assertEqual(len(s0), 1)
        self.assertEqual(len(s1), 1)
        self.assertEqual(len(s2), 1)
        self.assertEqual(len(s3), 1)
        self.assertEqual(len(cout), 1)

        avals = list(range(0, 16)) * 2
        bvals = list(range(0, 16)) * 2
        cinvals = [0] * 16 + [1] * 16

        sim = pyrtl.Simulation()
        for a in range(0, 16):
            for b in range(0, 16):
                for cin in range(0, 1):
                    sim.step({
                        'a[0]': a & 0x1,
                        'a[1]': (a & 0x2) >> 1,
                        'a[2]': (a & 0x4) >> 2,
                        'a[3]': (a & 0x8) >> 3,
                        'b[0]': b & 0x1,
                        'b[1]': (b & 0x2) >> 1,
                        'b[2]': (b & 0x4) >> 2,
                        'b[3]': (b & 0x8) >> 3,
                        'cin': cin
                    })
                    res = a + b + cin
                    self.assertEqual(sim.inspect('s[0]'), res & 0x1)
                    self.assertEqual(sim.inspect('s[1]'), (res & 0x2) >> 1)
                    self.assertEqual(sim.inspect('s[2]'), (res & 0x4) >> 2)
                    self.assertEqual(sim.inspect('s[3]'), (res & 0x8) >> 3)
                    self.assertEqual(sim.inspect('cout'), (res & 0x10) >> 4)

    def test_blif_with_clock_passing(self):
        pyrtl.input_from_blif(clock_passing_blif)
        a, b, c = [
            pyrtl.working_block().get_wirevector_by_name(s) for s in ['a', 'b', 'c']
        ]
        io_input = pyrtl.working_block().wirevector_subset(pyrtl.Input)
        self.assertEqual({a, b}, io_input)
        io_output = pyrtl.working_block().wirevector_subset(pyrtl.Output)
        self.assertEqual({c}, io_output)

        sim = pyrtl.Simulation()
        sim.step_multiple({
            'a': [0, 3, 1, 1, 1, 1, 0],
            'b': [1, 7, 9, 9, 9, 9, 0],
        })
        cvals = sim.tracer.trace[c]
        self.assertEqual(cvals, [0, 0, 0, 1, 1, 1, 0])


if __name__ == "__main__":
    unittest.main()
