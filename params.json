{"name":"PyRTL","tagline":" register-transfer-level hardware design and simulation","body":"\r\nPyRTL provides a collection of classes for pythonic [register-transfer level] (https://en.wikipedia.org/wiki/Register-transfer_level) design, simulation, tracing, and testing \r\nsuitable for teaching and research. Simplicity, usability, clarity, and extensibility rather than\r\nperformance or optimization is the overarching goal.  Features include:\r\n\r\n* Elaboration-through-execution, meaning all of Python can be used including introspection\r\n* Design, instantiate, and simulate all in one file and without leaving Python\r\n* Export to, or import from, common HDLs (BLIF-in, Verilog-out currently supported)\r\n* Examine execution with waveforms on the terminal or export to a .vcd as projects scale\r\n* Elaboration, synthesis, and basic optimizations all included\r\n* Small and well-defined internal core structure means writing new transforms is easier\r\n* Batteries included means many useful components are already available and more are coming every week\r\n\r\n![Command-line waveform for PyRTL state machine]( docs/screenshots/pyrtl-statemachine.png?raw=true \"PyRTL State Machine Screenshot\")\r\n\r\n### The 10,000 Foot Overview\r\n\r\nAt a high level PyRTL builds the hardware structure that you *explicitly define*.  If you are looking for a \r\ntool to take your random python code and turn it into hardware, you will have to look elsewhere.  Instead \r\nPyRTL is designed to help you concisely and precisely describe a hardware structure (that you already have \r\nworked out in detail) in python.  To the user it provides a set of python classes that allow you to express those \r\nhardware designs reasonably pythonically.  For example, with WireVector you get a structure that acts very \r\nmuch like a python list of 1-bit wires, so that ```mywire[0:-1]``` selects everything except the \r\nmost-significant-bit.  Of course you can add, subtract, and multiply these WireVectors or concat multiple\r\nbit-vectors end-to-end as well.  You can then even make normal python collections of those WireVectors and \r\ndo operations on them in bulk. For example, if you have a list of *n* different k-bit WireVectors (called \"x\") and you \r\nwant to multiply each of them by 2 and put the sum of the result in a WireVector \"y\", it looks like\r\nthe following:  ```y = sum([elem * 2 for elem in x])```. \r\nHardware comprehensions are surprisingly useful!\r\n\r\n### Hello N-bit Ripple-Carry Adder!\r\n\r\nWhile adders are a builtin primitive for PyRTL, most people doing RTL are familiar with the idea of a \r\n[Ripple-Carry Adder](https://en.wikipedia.org/wiki/Adder_(electronics)) and so it is useful to see how you \r\nmight express one in PyRTL if you had to.  Rather than the typical [Verilog introduction to fixed 4-bit \r\nadders](https://www.youtube.com/watch?v=bL3ihMA8_Gs), let's go ahead and build an *arbitrary* bitwidth \r\nadder!.\r\n\r\n```python\r\ndef one_bit_add(a, b, cin):\r\n    assert len(a) == len(b) == 1  # len returns the bitwidth\r\n    sum = a ^ b ^ cin  # operators on WireVectors build the hardware\r\n    cout = a & b | a & cin | b & cin\r\n    return sum, cout\r\n\r\ndef ripple_add(a, b, cin=0):\r\n    a, b = pyrtl.match_bitwidth(a, b)\r\n    if len(a) == 1:\r\n        sumbits, cout = one_bit_add(a, b, cin)\r\n    else:\r\n        lsbit, ripplecarry = one_bit_add(a[0], b[0], cin)\r\n        msbits, cout = ripple_add(a[1:], b[1:], ripplecarry)\r\n        sumbits = pyrtl.concat(msbits, lsbit)\r\n    return sumbits, cout\r\n\r\n# instantiate an adder into a 3-bit counter\r\ncounter = pyrtl.Register(bitwidth=3, name='counter')\r\nsum, cout = ripple_add(counter, pyrtl.Const(\"1'b1\"))\r\ncounter.next <<= sum\r\n\r\n# simulate the instantiated design for 15 cycles\r\nsim_trace = pyrtl.SimulationTrace()\r\nsim = pyrtl.Simulation(tracer=sim_trace)\r\nfor cycle in range(15):\r\n    sim.step({})\r\nsim_trace.render_trace()\r\n```\r\n\r\nThe code above includes an adder generator with python-style slices on wires (ripple_add), an instantiation \r\nof a register (used as a counter with the generated adder), and all the code needed to simulate the design, \r\ngenerate a waveform, and render it to the terminal. The way this particular code works is described more in \r\nthe examples directory.  When you run it, it should look like this (you can see the counter going from 0 to 7 and repeating):\r\n\r\n![Command-line waveform for PyRTL counter](docs/screenshots/pyrtl-counter.png?raw=true \"PyRTL Counter Screenshot\")\r\n\r\n\r\n### A Few Gotchas\r\n\r\nWhile python is an amazing language, DSLs in python always forced to make a few compromises which can sometime catch\r\nusers in some unexpected ways.  Watch out for these couple of \"somewhat surprising features\"\r\n\r\n* PyRTL never uses any of the \"in-place arithmetic assignments\" such as ```+=``` or ```&=``` in the traditional ways.\r\n  Instead only ```<<=``` and ```|=``` are defined and they are used for wire-assignment and conditional-wire-assignment\r\n  respectively (more on both of these in the examples).   If you declare a ```x = WireVector(bitwidth=3)``` and \r\n  ```y = WireVector(bitwidth=5)```, how do you assign ```x``` the value of ```y + 1```?  If you do ```x = y + 1``` \r\n  that will replace the old definition of ```x``` entirely?  Instead you need to write ```x <<= y + 1``` which you \r\n  can read as \"x gets its value from y + 1\".\r\n\r\n* The example above also shows off another aspect of PyRTL.  The bitwidth of ```y``` is 5.  The bitwidth of ```y + 1```\r\n  is actually 6 (PyRTL infers this automatically).  But then when you assign ```x <<= y + 1``` you are taking\r\n  a 6-bit value and assigning it to 3-bit value.  This is completely legal and only the least significant bits \r\n  will be assigned.  Mind your bitwidths.\r\n\r\n* PyRTL provides some handy functions on WireVectors, including ```==``` and ```<``` which evaluate to a new WireVector\r\n  a single bit long to hold the result of the comparison.  The bitwise operators ```&```, ```|```, ```~``` and ```^```\r\n  are also defined (however logic operations such as \"and\" and \"not\" are not).  A really tricky gotcha happens\r\n  when you start combining the two together.  Consider: ```doit = ready & state==3```.  In python, the bitwise\r\n  ```&``` operator has *higher precedence* than ```==```, thus python parses this as ```doit = (ready & state)==3```\r\n  instead of what you might have guessed at first!  Make sure to use parenthesis when using comparisons with\r\n  logic operations to be clear: ```doit = ready & (state==3)```.\r\n\r\n* PyRTL right now assumes that all WireVectors are unsigned integers.  When you do comparisons\r\n  such as \"<\" it will do unsigned comparison.  If you pass a WireVector to a function that requires more bits \r\n  that you have provided, it will do zero extension by default.  You can always explicitly do sign extension\r\n  with .sign_extend() but it is not the default behavior for WireVector.  This is right now for clarity and\r\n  consistency, although it does make writing signed arithmetic operations more text heavy.\r\n\r\n### Related Projects\r\n\r\n[MyHDL](http://www.myhdl.org/) is a neat Python hardware project built around generators and decorators.  The semantics of this embedded language\r\nare close to Verilog and unlike PyRTL, MyHDL allows asynchronous logic and higher level modeling.  Much like Verilog, only a structural\r\n\"convertible subset\" of the language can be automatically synthesized into real hardware.  PyRTL requires all logic to be both synchronous\r\nand synthesizable which avoids a common trap for beginners, it elaborates the design during execution allowing the full power of python\r\nin describing recursive or complex hardware structures, and allows for hardware synthesis, simulation, test bench creation, and optimization\r\nall in the same framework.\r\n\r\n[Chisel](https://chisel.eecs.berkeley.edu/) is a project with similar goals to PyRTL but is based instead in Scala.  Using the Scala\r\nembedded language features and rich type system, Chisel is (like PyRTL) a elaborate-through-execution hardware design language.  With support\r\nfor signed types, named hierarchies of wires useful for hardware protocols, and a neat control structure call \"when\" that inspired our\r\nConditionalUpdate contexts, Chisel is a powerful tool used in some great research projects including OpenRISC.  Unlike Chisel, PyRTL has\r\nconcentrated on a complete tool chain which is useful for instructional projects, and provides a clearly defined and relatively easy to\r\nmanipulate intermediate structure in the class Block (often times call pyrtl.core) which allows rapid prototyping of hardware analysis\r\nroutines which can then be codesigned with the architecture.\r\n\r\n[Yosys](http://www.clifford.at/yosys/) is an open source tool for Verilog RTL synthesis. It supports a huge subset of the Verilog-2005\r\nsemantics and provides a basic set of synthesis algorithms.  The goals of this tool are quite different from PyRTL, but the two\r\nplay very nicely together in that PyRTL can output Verilog that can then be synthesized through Yosys.  Likewise Yosys can take\r\nVerilog designs and synthesize them to a very simple library of gates and output them as a \"blif\" file which can then be read in by\r\nPyRTL.\r\n\r\n[PyMTL](https://github.com/cornell-brg/pymtl) is an alpha stage \"open-source Python-based framework for multi-level hardware modeling\".\r\nOne of the neat things about this project is that they are trying to allow simulation and modeling at multiple different levels of the\r\ndesign from the functional level, the cycle-close level, and down to the register-transfer level (where PyRTL really is built to play).\r\nLike MyHDL they do some neat meta-programming tricks like parsing the Python AST to allow executable software descriptions to be (under\r\ncertain restrictions -- sort of like verilog) automatically converted into implementable hardware.  PyRTL, on the other hand, is about\r\nproviding a limited and composable set of data structures to be used to specify an RTL implementation, thus avoiding the distinction between\r\nsynthesizable and non-synthesizable code (the execution is the elaboration step).\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}
