<!DOCTYPE html>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-67968360-1', 'auto');
  ga('send', 'pageview');
</script>


<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>PyRTL by UCSBarchlab</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/tabs.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <img src="https://pyrtl.readthedocs.io/en/latest/_static/pyrtl_logo.png" alt="PyRTL (logo)">
      <h2 class="project-tagline"> register-transfer-level hardware design and simulation</h2>
      <a href="http://pyrtl.readthedocs.org/" class="btn">Read the Docs</a>
      <a href="https://github.com/UCSBarchlab/PyRTL/tree/master/examples" class="btn">See Examples</a>
      <a href="https://github.com/UCSBarchlab/PyRTL" class="btn">View on GitHub</a>
      <a href="https://mybinder.org/v2/gh/UCSBarchlab/PyRTL/development?filepath=%2Fipynb-examples%2F" class="btn">Run Notebook</a>
      <!-- <a href="https://github.com/UCSBarchlab/PyRTL/tarball/master" class="btn">Download .tar.gz</a> -->
    </section>

<section class="main-content">

<h3>
<a id="getting-started" class="anchor" href="#getting-started" aria-hidden="true"><span class="octicon octicon-link"></span></a>Getting Started</h3>

<p><code>pip3 install pyrtl</code> &nbsp; or &nbsp; <code>pip install pyrtl</code></p>
  
<h3>
<a id="pyrtl-features" class="anchor" href="#pyrtl-features" aria-hidden="true"><span class="octicon octicon-link"></span></a>PyRTL Features</h3>

<p>PyRTL provides a collection of classes for Pythonic <a href="https://en.wikipedia.org/wiki/Register-transfer_level">register-transfer level</a> design, simulation, tracing, and testing 
suitable for teaching and research. Simplicity, usability, clarity, and extensibility rather than
performance or optimization is the overarching goal.  Features include:</p>

<ul>
<li>Elaboration-through-execution, meaning all of Python can be used including introspection</li>
<li>Design, instantiate, and simulate all in one file and without leaving Python</li>
<li>Export to, or import from, common HDLs (BLIF-in, Verilog-out currently supported)</li>
<li>Examine execution with waveforms on the terminal or export to a .vcd as projects scale</li>
<li>Elaboration, synthesis, and basic optimizations all included</li>
<li>Small and well-defined internal core structure means writing new transforms is easier</li>
<li>Batteries included means many useful components are already available and more are coming every week</li>
</ul>

  <p><b>New in 0.8.7:</b> SimCompiled provides seamless JIT to C for simulation performance, new hardware
    modules for PRNG, fixes for lots of issues with Verilog generation (support for memory and testbench generation both improved
    significantly), convenience functions for integer log2 and truncate, and
    even more examples in the documentation.</p>
  
<p>Here are some simple examples of PyRTL in action.  These examples implement the same functionality as those highlighted in the
  wonderful related work <a href="https://chisel.eecs.berkeley.edu/">Chisel</a>, which in turn allows us to see the stylistic differences
  between the approaches.</p>
  
<!-- Tab links -->
<div class="tab">
  <button class="tablinks" onclick="openCode(event, 'FIR')" id="defaultOpen"> FIR </button>
  <button class="tablinks" onclick="openCode(event, 'GCD')"> GCD </button>
  <button class="tablinks" onclick="openCode(event, 'MaxN')">MaxN</button>
  <button class="tablinks" onclick="openCode(event, 'Mul')">Mul</button>
  <button class="tablinks" onclick="openCode(event, 'Adder')">Adder</button>
</div>

<!-- Code example formatted with https://dillinger.io/ -->
<div id="FIR" class="tabcontent">
  <p>A finite impulse response filter  -- this function generates a sequential curcuit that grabs input <code>x</code> and a list of coefficients<code>bs</code>. If one looks to the
    <a href="https://en.wikipedia.org/wiki/Finite_impulse_response">Wikipedia FIR description</a> you can see that list <code>zs</code> is the registers required
    to implement the delay.  The function returns an output "y" which is the resulting sum of products and is valid every cycle (since the design is naturally fully
    pipelined).  The code below the <code>fir</code> function is everything needed to instantiate, simulate, and visualize the resulting design.</p>
<pre><code class="has-line-data" data-line-start="1" data-line-end="22" class="language-python"><span class="hljs-keyword">import</span> pyrtl

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fir</span><span class="hljs-params">(x, bs)</span>:</span>
    rwidth = len(x)  <span class="hljs-comment"># bitwidth of the registers</span>
    ntaps = len(bs) <span class="hljs-comment"># number of coefficients</span>

    zs = [x] + [pyrtl.Register(rwidth) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(ntaps-<span class="hljs-number">1</span>)]
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,ntaps):
        zs[i].next &lt;&lt;= zs[i-<span class="hljs-number">1</span>]

    <span class="hljs-comment"># produce the final sum of products</span>
    <span class="hljs-keyword">return</span> sum(z*b <span class="hljs-keyword">for</span> z,b <span class="hljs-keyword">in</span> zip(zs, bs))

x = pyrtl.Input(<span class="hljs-number">8</span>, <span class="hljs-string">'x'</span>)
y = pyrtl.Output(<span class="hljs-number">8</span>, <span class="hljs-string">'y'</span>)
y &lt;&lt;= fir(x, [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>])

sim = pyrtl.Simulation()
sim.step_multiple({<span class="hljs-string">'x'</span>:[<span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">18</span>, <span class="hljs-number">8</span>, <span class="hljs-number">17</span>, <span class="hljs-number">7</span>, <span class="hljs-number">16</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">5</span>]})
sim.tracer.render_trace()
</code></pre>
</div>

  
<div id="GCD" class="tabcontent">
  <p>A greatest common demoninator calculator -- this function generates a sequential curcuit that grabs inputs <code>a</code> and <code>b</code> when <code>e</code> goes high, 
  and then, while <code>e</code> is low, calculates the GCD through iterative subtraction.  The function returns two "wires", one which will hold the value 
  when it is ready, and the other which is a boolean ready signal.</p>
<pre><code class="has-line-data" data-line-start="1" data-line-end="20" class="language-python"><span class="hljs-keyword">from</span> pyrtl <span class="hljs-keyword">import</span> *

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gcd</span><span class="hljs-params">(a, b, begin)</span>:</span>
    x = Register(len(a))
    y = Register(len(b))
    done = WireVector(<span class="hljs-number">1</span>)

    <span class="hljs-keyword">with</span> conditional_assignment:
        <span class="hljs-keyword">with</span> begin:
            x.next |= a
            y.next |= b
        <span class="hljs-keyword">with</span> x &gt; y:
            x.next |= x - y
        <span class="hljs-keyword">with</span> y &gt; x:
            y.next |= y - x
        <span class="hljs-keyword">with</span> otherwise:
            done |= <span class="hljs-keyword">True</span>
    <span class="hljs-keyword">return</span> x, done
</code></pre>
</div>

<div id="MaxN" class="tabcontent">
  <p>MaxN generates hardware that take N inputs and calculates the max of them.  This example makes use of Python's notation
  for handling multiple inputs which packs them nicely into a list for you.  It is also a nice demonstration that the full power of 
  Python is available to you in PyRTL including functional tools like reduce (here chaining together multiple <code>max2</code> elements into a
  bigger maxN), map, recursion, lambdas, etc.</p>
<pre><code class="has-line-data" data-line-start="1" data-line-end="9" class="language-python"><span class="hljs-keyword">from</span> pyrtl <span class="hljs-keyword">import</span> *
<span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">max_n</span><span class="hljs-params">(*inputs)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">max_2</span><span class="hljs-params">(x,y)</span>:</span>
        <span class="hljs-keyword">return</span> select(x&gt;y, x, y)
    <span class="hljs-keyword">return</span> reduce(max_2, inputs)
</code></pre>
</div>

<div id="Mul" class="tabcontent">
  <p>Mul generates a small 4 x 4 multiplier with a simple table lookup.  The first line simple checks that the inputs are each 4-bits wide.
  The next is a Python function that gives us the values we want stored in the ROM as a function of the address.  The ROM is automatically initialized with that
  function.  The final hardware generated simply concatenates the two 4-bit inputs into an single 8-bit address and returns the value at
  that ROM address.</p>
<pre><code class="has-line-data" data-line-start="2" data-line-end="10" class="language-python"><span class="hljs-keyword">from</span> pyrtl <span class="hljs-keyword">import</span> *

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mul</span><span class="hljs-params">(x, y)</span>:</span>
    <span class="hljs-keyword">assert</span>(len(x) == <span class="hljs-number">4</span> <span class="hljs-keyword">and</span> len(y) == <span class="hljs-number">4</span>)
    romdata = <span class="hljs-keyword">lambda</span> addr: (addr &gt;&gt; <span class="hljs-number">4</span>) * (addr &amp; <span class="hljs-number">0xf</span>)
    tbl = RomBlock(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>, romdata)
    <span class="hljs-keyword">return</span> tbl[concat(x,y)]
</code></pre>
</div>

<div id="Adder" class="tabcontent">
  <p>The classic ripple-carry adder -- this function generates a ripple carry adder of abitrary length including both carry in and carry out.
    The full adder ("fa") takes 1-bit inputs and produces 1-bit outputs.  We iteratively generate full adders and link the carry in of each
    new adder to the carry out of the prior.  A Python dictionary keeps track of the wires carrying the sum bits as we iterate through.  The final
    sum is then just the concatenation of the wires in that dictionary.</p>
<pre><code class="has-line-data" data-line-start="2" data-line-end="21" class="language-python"><span class="hljs-keyword">from</span> pyrtl <span class="hljs-keyword">import</span> *
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fa</span><span class="hljs-params">(x, y, cin)</span>:</span>
    sum = x ^ y ^ cin
    cout = x&amp;y | y&amp;cin | x&amp;cin
    <span class="hljs-keyword">return</span> sum, cout

<span class="hljs-comment"># An n-bit ripple carry adder with carry in and carry out</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">adder</span><span class="hljs-params">(a, b, cin)</span>:</span>
    a, b = match_bitwidth(a, b)
    n = len(a)

    sum = {}
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):
        sum[i], cout = fa(a[i], b[i], cin)
        cin = cout
    full_sum = concat_list([sum[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n)])
    <span class="hljs-keyword">return</span> full_sum, cout
</code></pre>
</div>

<script>
function openCode(evt, codeName) {
  // Declare all variables
  var i, tabcontent, tablinks;

  // Get all elements with class="tabcontent" and hide them
  tabcontent = document.getElementsByClassName("tabcontent");
  for (i = 0; i < tabcontent.length; i++) {
    tabcontent[i].style.display = "none";
  }

  // Get all elements with class="tablinks" and remove the class "active"
  tablinks = document.getElementsByClassName("tablinks");
  for (i = 0; i < tablinks.length; i++) {
    tablinks[i].className = tablinks[i].className.replace(" active", "");
  }

  // Show the current tab, and add an "active" class to the button that opened the tab
  document.getElementById(codeName).style.display = "block";
  evt.currentTarget.className += " active";
}
// Get the element with id="defaultOpen" and click on it
document.getElementById("defaultOpen").click();
</script>

<p> PyRTL can also produce visualizations of your design, such as this graph of the GCD sequential circuit described previously:</p>
<p><img src="https://raw.githubusercontent.com/UCSBarchlab/PyRTL/master/docs/images/gcd-graph.png?raw=true" alt="GraphViz visualization of the GCD circuit" title="GCD GraphViz Image"></p>

<h3>
<a id="the-10000-foot-overview" class="anchor" href="#the-10000-foot-overview" aria-hidden="true"><span class="octicon octicon-link"></span></a>The 10,000 Foot Overview</h3>

<p>At a high level PyRTL builds the hardware structure that you <em>explicitly define</em>.  If you are looking for a 
tool to take your random Python code and turn it into hardware, you will have to look elsewhere 
-- this is <b>not</b> <a href="https://en.wikipedia.org/wiki/High-level_synthesis">HLS</a>.
Instead PyRTL is designed to help you concisely and precisely describe a digital hardware structure (that you already have 
worked out in detail) in Python.  PyRTL restricts you to a set of reasonable digital designs practices -- the clock and resets
are implicit, block memories are synchronous by default, there are no "undriven" states, and no weird un-registered feedbacks are
allowed.  Instead, of worrying about these "analog-ish" tricks that are horrible ideas in modern processes anyways, PyRTL lets
you treat hardware design like a software problem -- build recursive hardware, write instrospective containers,
and have fun building digital designs again!</p>

<p>To the user it provides a set of Python classes that allow them to express their 
hardware designs reasonably Pythonically.  For example, with WireVector you get a structure that acts very 
much like a Python list of 1-bit wires, so that <code>mywire[0:-1]</code> selects everything except the 
most-significant-bit.  Of course you can add, subtract, and multiply these WireVectors or concat multiple
bit-vectors end-to-end as well.  You can then even make normal Python collections of those WireVectors and 
do operations on them in bulk. For example, if you have a list of <em>n</em> different k-bit WireVectors (called "x") and you 
want to multiply each of them by 2 and put the sum of the result in a WireVector "y", it looks like
the following:  <code>y = sum([elem * 2 for elem in x])</code>. Hardware comprehensions are surprisingly useful.  Below we get into
an example in more detail, but if you just want to play around with PyRTL
<a href="https://mybinder.org/v2/gh/UCSBarchlab/PyRTL/development?filepath=%2Fipynb-examples%2F"> try Jupyter Notebooks on any
  of our examples on MyBinder</a>.</p>

<h3>
<a id="hello-n-bit-ripple-carry-adder" class="anchor" href="#hello-n-bit-ripple-carry-adder" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hello N-bit Ripple-Carry Adder!</h3>

<p>While adders are a builtin primitive for PyRTL, most people doing RTL are familiar with the idea of a 
<a href="https://en.wikipedia.org/wiki/Adder_(electronics)">Ripple-Carry Adder</a> and so it is useful to see how you 
might express one in PyRTL if you had to.  Rather than the typical <a href="https://www.youtube.com/watch?v=bL3ihMA8_Gs">Verilog introduction to fixed 4-bit 
adders</a>, let's go ahead and build an <em>arbitrary</em> bitwidth 
adder.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">one_bit_add</span>(<span class="pl-smi">a</span>, <span class="pl-smi">b</span>, <span class="pl-smi">carry_in</span>):
    <span class="pl-k">assert</span> <span class="pl-c1">len</span>(a) <span class="pl-k">==</span> <span class="pl-c1">len</span>(b) <span class="pl-k">==</span> <span class="pl-c1">1</span>  <span class="pl-c"># len returns the bitwidth</span>
    <span class="pl-c1">sum</span> <span class="pl-k">=</span> a <span class="pl-k">^</span> b <span class="pl-k">^</span> carry_in  <span class="pl-c"># operators on WireVectors build the hardware</span>
    carry_out <span class="pl-k">=</span> a <span class="pl-k">&amp;</span> b <span class="pl-k">|</span> a <span class="pl-k">&amp;</span> carry_in <span class="pl-k">|</span> b <span class="pl-k">&amp;</span> carry_in
    <span class="pl-k">return</span> <span class="pl-c1">sum</span>, carry_out

<span class="pl-k">def</span> <span class="pl-en">ripple_add</span>(<span class="pl-smi">a</span>, <span class="pl-smi">b</span>, <span class="pl-smi">carry_in</span><span class="pl-k">=</span><span class="pl-c1">0</span>):
    a, b <span class="pl-k">=</span> pyrtl.match_bitwidth(a, b)
    <span class="pl-k">if</span> <span class="pl-c1">len</span>(a) <span class="pl-k">==</span> <span class="pl-c1">1</span>:
        sumbits, carry_out <span class="pl-k">=</span> one_bit_add(a, b, carry_in)
    <span class="pl-k">else</span>:
        lsbit, ripplecarry <span class="pl-k">=</span> one_bit_add(a[<span class="pl-c1">0</span>], b[<span class="pl-c1">0</span>], carry_in)
        msbits, carry_out <span class="pl-k">=</span> ripple_add(a[<span class="pl-c1">1</span>:], b[<span class="pl-c1">1</span>:], ripplecarry)
        sumbits <span class="pl-k">=</span> pyrtl.concat(msbits, lsbit)
    <span class="pl-k">return</span> sumbits, carry_out

<span class="pl-c"># instantiate an adder into a 3-bit counter</span>
counter <span class="pl-k">=</span> pyrtl.Register(<span class="pl-smi">bitwidth</span><span class="pl-k">=</span><span class="pl-c1">3</span>, <span class="pl-smi">name</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>counter<span class="pl-pds">'</span></span>)
<span class="pl-c1">sum</span>, carry_out <span class="pl-k">=</span> ripple_add(counter, pyrtl.Const(<span class="pl-s"><span class="pl-pds">"</span>1'b1<span class="pl-pds">"</span></span>))
counter.next <span class="pl-k">&lt;&lt;=</span> <span class="pl-c1">sum</span>

<span class="pl-c"># simulate the instantiated design for 15 cycles</span>
sim_trace <span class="pl-k">=</span> pyrtl.SimulationTrace()
sim <span class="pl-k">=</span> pyrtl.Simulation(<span class="pl-smi">tracer</span><span class="pl-k">=</span>sim_trace)
<span class="pl-k">for</span> cycle <span class="pl-k">in</span> <span class="pl-c1">range</span>(<span class="pl-c1">15</span>):
    sim.step({})
sim_trace.render_trace()</pre></div>

<p>The code above includes an adder generator with Python-style slices on wires (ripple_add), an instantiation 
of a register (used as a counter with the generated adder), and all the code needed to simulate the design, 
generate a waveform, and render it to the terminal. The way this particular code works is described more in 
the examples directory.  When you run it, it should look like this (you can see the counter going from 0 to 7 and repeating):</p>

<p><img src="https://raw.githubusercontent.com/UCSBarchlab/PyRTL/master/docs/screenshots/pyrtl-counter.png?raw=true" alt="Command-line waveform for PyRTL counter" title="PyRTL Counter Screenshot"></p>

<h3>
<a id="a-few-gotchas" class="anchor" href="#a-few-gotchas" aria-hidden="true"><span class="octicon octicon-link"></span></a>A Few Gotchas</h3>

<p>While Python is an amazing language, DSLs in Python are always forced to make a few compromises which can sometimes catch
users in some unexpected ways.  Watch out for these couple of "somewhat surprising features":</p>

<ul>
<li><p>PyRTL never uses any of the "in-place arithmetic assignments" such as <code>+=</code> or <code>&amp;=</code> in the traditional ways.
Instead only <code>&lt;&lt;=</code> and <code>|=</code> are defined and they are used for wire-assignment and conditional-wire-assignment
respectively (more on both of these in the examples).   If you declare a <code>x = WireVector(bitwidth=3)</code> and 
<code>y = WireVector(bitwidth=5)</code>, how do you assign <code>x</code> the value of <code>y + 1</code>?  If you do <code>x = y + 1</code> 
that will replace the old definition of <code>x</code> entirely.  Instead you need to write <code>x &lt;&lt;= y + 1</code> which you 
can read as "x gets its value from y + 1".</p></li>
<li><p>The example above also shows off another aspect of PyRTL.  The bitwidth of <code>y</code> is 5.  The bitwidth of <code>y + 1</code>
is actually 6 (PyRTL infers this automatically).  But then when you assign <code>x &lt;&lt;= y + 1</code> you are taking
a 6-bit value and assigning it to 3-bit value.  This is completely legal and only the least significant bits 
will be assigned.  Mind your bitwidths.</p></li>
<li><p>PyRTL provides some handy functions on WireVectors, including <code>==</code> and <code>&lt;</code> which evaluate to a new WireVector
a single bit long to hold the result of the comparison.  The bitwise operators <code>&amp;</code>, <code>|</code>, <code>~</code> and <code>^</code>
are also defined (however logic operations such as "and" and "not" are not).  A really tricky gotcha happens
when you start combining the two together.  Consider: <code>doit = ready &amp; state==3</code>.  In Python, the bitwise
<code>&amp;</code> operator has <em>higher precedence</em> than <code>==</code>, thus Python parses this as <code>doit = (ready &amp; state)==3</code>
instead of what you might have guessed at first!  Make sure to use parentheses when using comparisons with
logic operations to be clear: <code>doit = ready &amp; (state==3)</code>.</p></li>
<li><p>PyRTL right now assumes that all WireVectors are unsigned integers.  When you do comparisons
such as "&lt;" it will do unsigned comparison.  If you pass a WireVector to a function that requires more bits 
that you have provided, it will do zero extension by default.  You can always explicitly do sign extension
with .sign_extended() but it is not the default behavior for WireVector.  For now, this is for clarity and
consistency, although it does make writing signed arithmetic operations more text heavy.</p></li>
</ul>

<p><img src="https://raw.githubusercontent.com/UCSBarchlab/PyRTL/master/docs/screenshots/pyrtl-statemachine.png?raw=true" alt="Command-line waveform for PyRTL state machine" title="PyRTL State Machine Screenshot"></p>

  
<h3>
<a id="related-projects" class="anchor" href="#related-projects" aria-hidden="true"><span class="octicon octicon-link"></span></a>Related Projects</h3>

<p><a href="https://github.com/amaranth-lang/amaranth">Amaranth (previously nMigen)</a> </a> is another python hardware project providing an open-source toolchain
that has a lot of wonderful stuff for working with FPGAs in particular.  It has support for evaluation board definitions, a System-on-Chip toolkit, and more.
I think it has a similar philosophy of trying to be easy to learn and use and simplify the design of complex hardware with reusable components.  Amaranth
(at the time of writing) has much better support on the back end for a variety of real devices and low level stuff like managing clock domains, but pyrtl
I think it provides some value in getting going right in the command line and how it handles memories etc.  I would be eager to see the power of these tools
combined in some way!

<p><a href="https://chisel.eecs.berkeley.edu/">Chisel</a> is a project with similar goals to PyRTL but is based instead in Scala.  Scala
provides some very helpful embedded language features and a rich type system. Chisel is (like PyRTL) a elaborate-through-execution hardware design language.  With support
for signed types, named hierarchies of wires useful for hardware protocols, and a neat control structure call "when" that inspired our
conditional contexts, Chisel is a powerful tool used in some great research projects including OpenRISC.  Unlike Chisel, PyRTL has
concentrated on a simple to use and complete tool chain which is useful for instructional projects, and provides a clearly defined and relatively easy-to-manipulate
intermediate structure in the class Block (often times call pyrtl.core) which allows rapid prototyping of hardware analysis
routines which can then be codesigned with the architecture.</p>
  
<p><a href="https://github.com/SpinalHDL/SpinalHDL">SpinalHDL</a> is a different approach to HDL in Scala and is very much aligned with the way
PyRTL is built (invented independently it is neat to see the convergent evolution which, I think, points to something deeper about hardware
design).  It has a lot of support and really well thought out structures.  

<p><a href="http://www.myhdl.org/">MyHDL</a> is another neat Python hardware project built around generators and decorators.  The semantics of this embedded language
are close to Verilog and unlike PyRTL, MyHDL allows asynchronous logic and higher level modeling.  Much like Verilog, only a structural
"convertible subset" of the language can be automatically synthesized into real hardware.  PyRTL requires all logic to be both synchronous
and synthesizable which avoids a common trap for beginners, it elaborates the design during execution allowing the full power of Python
in describing recursive or complex hardware structures, and it allows for hardware synthesis, simulation, test bench creation, and optimization
all in the same framework.</p>
  
<p><a href="http://www.clifford.at/yosys/">Yosys</a> is an open source tool for Verilog RTL synthesis. It supports a huge subset of the Verilog-2005
semantics and provides a basic set of synthesis algorithms.  The goals of this tool are quite different from PyRTL, but the two
play very nicely together in that PyRTL can output Verilog that can then be synthesized through Yosys.  Likewise Yosys can take
Verilog designs and synthesize them to a very simple library of gates and output them as a "blif" file which can then be read in by
PyRTL.</p>

<p><a href="https://pymtl.github.io/">PyMTL3</a> (a.k.a. Mamba) is an beta stage an "open-source Python-based hardware generation, simulation, and
verification framework with multi-level hardware modeling support".  One of the neat things about this project is that they are trying to allow
simulation, modeling, and verification at multiple different levels of the
design from the functional level, the cycle-close level, and down to the register-transfer level (where PyRTL really is built to play).
Like MyHDL they do some meta-programming tricks like parsing the Python AST to allow executable software descriptions to be (under
certain restrictions -- sort of like Verilog) automatically converted into implementable hardware.  PyRTL, on the other hand, is about
providing a limited and composable set of data structures to be used to specify an RTL implementation, thus avoiding the distinction between
synthesizable and non-synthesizable code (the execution is the elaboration step).</p>

<p><a href="http://www.clash-lang.org/">CλaSH</a> is a hardware description embedded DSL in Haskell. Like PyRTL it provides an
approach suitable for both combinational and synchronous sequential circuits and allows the transform
of these high-level descriptions to low-level synthesizable Verilog HDL.  Unlike PyRTL, designs are statically
typed (like VHDL), yet with a very high degree of type inference, enabling both safe and fast prototying using concise
descriptions.  If you like functional programming and hardware also check out 
<a href="http://blog.raintown.org/p/lava.html">Lava</a>.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/UCSBarchlab/PyRTL">PyRTL</a> is maintained by <a href="https://github.com/UCSBarchlab">UCSBarchlab</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
